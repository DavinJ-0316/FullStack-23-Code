using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace GenericCollectionAttribute.Collection.Yield
{
    /// <summary>
    /// Yield return的演示示例
    /// Yield - 使用yield return 的方法称为 迭代器方法(iterator Method)
    /// 1. one by one return
    /// 2. return flow of control to the calling code.

    /// https://learn.microsoft.com/en-us/archive/msdn-magazine/2017/april/essential-net-understanding-csharp-foreach-internals-and-custom-iterators-with-yield
    /// https://learn.microsoft.com/en-us/archive/msdn-magazine/2017/june/essential-net-custom-iterators-with-yield
    /// 
    /// Deferred execution is supported directly in the C# language by the yield (C# Reference) keyword (in the form of the yield-return statement) 
    /// https://learn.microsoft.com/en-us/dotnet/standard/linq/deferred-execution-lazy-evaluation
    ///     
    /// </summary>


    public class YieldDemo
    {
        public void PrintYieldEventNumbers()
        {
            int index = 0;
            var numbers = YieldProduceEvenNumbers(15);

            //Console.WriteLine("Caller: about to iterate.");
            foreach (int i in numbers)
            {
                // yield method 看到 是一个一个打印下面的日志
                Console.WriteLine($"Yield return Caller: {i}");
                index++;

                if (index > 3) break;
            }
        }

        public void PrintCommonEventNumbers()
        {
            int index = 0;
            var numbers = CommonProduceEvenNumbers(15);
            // Console.WriteLine("Caller: about to iterate.");
            foreach (int i in numbers)
            {
                //common method 会看到 是一次性 打印下面的日志
                Console.WriteLine($"Common return Caller: {i}");
                index++;

                if (index > 3) break;
            }
        }

        
        /// 首先从观感上 能明显感受到 Power 的yield return确实是一个数值返回 休息2秒 
        /// 而Common方法 感受是休息了20秒后 返回所有的数据 并不是一个一个返回
        private IEnumerable<int> YieldProduceEvenNumbers(int upto)
        {
            //Console.WriteLine("Iterator: start.");
            for (int i = 0; i <= upto; i += 2)
            {
                Thread.Sleep(2000);
                yield return i;                
            }            
        }
       
        private List<int> CommonProduceEvenNumbers(int upto)
        {
            List<int> ints = new List<int>();
            //Console.WriteLine("Iterator: start.");
            for (int i = 0; i <= upto; i += 2)
            {
                Thread.Sleep(2000);
                ints.Add(i);
            }
            
            return ints;
        }
    }

    public class ExecutionOfYieldIterator
    {
        //iterator is executed until the first yield return statement is reached.
        //Then, the execution of an iterator is suspended and the caller gets the first iteration value and processes it
        public void Test()
        {
            var numbers = ProduceEvenNumbers(5);
            Console.WriteLine("Caller: about to iterate.");
            foreach (int i in numbers)
            {
                Console.WriteLine($"Caller: {i}");
            }
        }

        IEnumerable<int> ProduceEvenNumbers(int upto)
        {
            Console.WriteLine("Iterator: start.");
            for (int i = 0; i <= upto; i += 2)
            {
                Console.WriteLine($"Iterator: about to yield {i}");
                yield return i;
                Console.WriteLine($"Iterator: yielded {i}");
            }
            Console.WriteLine("Iterator: end.");
        }

        //yield also returns type IEnumerator
        //The compiler supports both, and actually if the return value is IEnumerable<T>,
        //the generated class will implement both interfaces where GetEnumerator() is implemented

        //A method using yield is rebuilt by the compiler. It creates a state machine with a whole new compiler-generated class.
        //This state-machine-class is an IEnumerator as well as an IEnumerable whose GetEnumerator method returns itself.

        // 更显而易见的地方是看一下compiler生成的代码 ：What auto generated by compiler - https://csharpindepth.com/articles/IteratorBlockImplementation
        IEnumerator<int> ProduceEvenNumbersReturnIterator(int upto)
        {
            Console.WriteLine("Iterator: start.");
            for (int i = 0; i <= upto; i += 2)
            {
                Console.WriteLine($"Iterator: about to yield {i}");
                yield return i;
                Console.WriteLine($"Iterator: yielded {i}");
            }

            Console.WriteLine("Iterator: end.");
        }
    }
}
